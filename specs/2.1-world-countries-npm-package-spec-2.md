# Country-State-City NPM Package - Complete Development Specification

## 📋 Table of Contents
1. [Project Overview](#project-overview)
2. [Problem Analysis](#problem-analysis)
3. [Architecture Decisions](#architecture-decisions)
4. [Package Structure](#package-structure)
5. [Data Organization](#data-organization)
6. [Implementation Details](#implementation-details)
7. [Build Configuration](#build-configuration)
8. [API Design](#api-design)
9. [Database Integration](#database-integration)
10. [Testing Requirements](#testing-requirements)
11. [Publishing Checklist](#publishing-checklist)

---

## 🎯 Project Overview

### Package Name
`@yourdb/country-state-city` (replace `yourdb` with your organization/username)

### Purpose
Create an official npm package for country, state, and city data that:
- Is always synced with your authoritative database
- Works reliably on iOS/Safari browsers
- Has minimal bundle size impact
- Uses modern lazy-loading architecture
- Provides TypeScript support

### Key Goals
1. **iOS Compatible** - No stack overflow errors on Safari/iOS
2. **Minimal Bundle Size** - <10KB initial load
3. **Lazy Loading** - Only load data when requested
4. **Always Updated** - Direct sync from your database
5. **Developer Friendly** - Simple API, full TypeScript support

---

## 🔍 Problem Analysis

### Why Existing Package Fails

#### Critical Issue: `country-state-city` by harpreetkhalsagtbit

**Their Data Structure (Source):**
```
data/
├── India-IN/
│   ├── Delhi-DL/
│   │   └── cities.json
│   └── allStates.json
└── United_States-US/
    ├── California-CA/
    │   └── cities.json
    └── allStates.json
```
✅ **Good structure in source code**

**Their Fatal Mistake:**
They run a build script `combineSplitFilesToMakeALargeDatasetFiles-CSC.ts` that:
1. Takes all split files
2. Combines them into 3 massive files:
   - `country.json` (all countries)
   - `state.json` (all states)
   - `city.json` (8MB - ALL cities worldwide)
3. Publishes these monolithic files to npm

**Published Structure:**
```typescript
// src/city.ts - Published to npm
import cityData from './assets/city.json'; // 8MB loaded immediately!

export class City {
  static getCitiesOfState(countryCode: string, stateCode: string) {
    // Even though you only want California cities,
    // it loads ALL 8MB of world cities first!
    return cityData.filter(city => 
      city.countryCode === countryCode && 
      city.stateCode === stateCode
    );
  }
}
```

**Result:**
- ❌ 8MB bundle size even for simple queries
- ❌ Static import means bundlers MUST include everything
- ❌ iOS Safari stack overflow when parsing 8MB JSON
- ❌ Tree-shaking claims are false - doesn't work
- ❌ 2MB gzipped minimum bundle size

### User-Reported Issues
1. "Maximum call stack exceeded error on iPhone" (GitHub #184, #173, #123)
2. "Works on Android/Windows but crashes iOS browsers"
3. "Bundle size too large - 2MB gzipped" (GitHub #93)
4. Users creating country-specific forks (e.g., `usa-state-city`)

### Root Cause
Apple reduced iOS Safari's maximum call stack size from ~1000 frames to <100 frames. Parsing 8MB of JSON in one go exceeds this limit.

---

## 🏗️ Architecture Decisions

### Core Principle: Never Combine Files

**DON'T:**
- ❌ Combine split files into monolithic JSONs
- ❌ Use static imports for data
- ❌ Load all data upfront

**DO:**
- ✅ Keep data split in published package
- ✅ Use dynamic imports (`import()`)
- ✅ Load data on-demand only

### Why Dynamic Imports?

```typescript
// ❌ WRONG - Static Import
import cityData from './data/city.json'; // Loads 8MB immediately
export const getCities = () => cityData;

// ✅ CORRECT - Dynamic Import
export async function getCities() {
  // Only loads when called
  const { default: data } = await import('./data/city.json');
  return data;
}
```

**Benefits:**
1. Bundlers can code-split automatically
2. Only requested data is downloaded
3. No upfront parsing overhead
4. iOS-safe - small chunks parsed separately

### Bundle Size Strategy

| User Action | Bundle Size | What Loads |
|-------------|-------------|------------|
| `import { getCountries }` | 5KB | Main code only |
| `await getCountries()` | +2KB = 7KB | Countries list |
| `await getStatesOfCountry('US')` | +30KB = 37KB | US states |
| `await getCitiesOfState('US', 'CA')` | +15KB = 52KB | California cities |

Compare to existing package: **8MB for everything, always**

---

## 📁 Package Structure

```
country-state-city/
├── src/
│   ├── index.ts                  # Main entry point
│   ├── types.ts                  # TypeScript interfaces
│   ├── loaders.ts                # Data loading functions
│   ├── utils.ts                  # Helper functions
│   └── data/                     # Data files (kept split!)
│       ├── countries.json        # ~5KB - Country list
│       ├── United_States-US/
│       │   ├── meta.json         # Country metadata with timezones
│       │   ├── states.json       # All states for US
│       │   ├── California-CA/
│       │   │   └── cities.json   # Cities in California
│       │   ├── Texas-TX/
│       │   │   └── cities.json
│       │   └── [other states]/
│       ├── India-IN/
│       │   ├── meta.json
│       │   ├── states.json
│       │   ├── Delhi-DL/
│       │   │   └── cities.json
│       │   └── [other states]/
│       └── [other countries]/
├── dist/                         # Build output (preserve structure!)
│   ├── index.js
│   ├── index.cjs
│   ├── index.d.ts
│   └── data/                     # Same structure as src/data
├── tests/
│   ├── unit/
│   │   ├── loaders.test.ts
│   │   └── utils.test.ts
│   ├── integration/
│   │   └── api.test.ts
│   └── compatibility/
│       └── ios-safari.test.ts
├── scripts/
│   ├── generate-data.ts          # Converts your DB to JSON
│   └── validate-data.ts          # Validates JSON structure
├── package.json
├── tsconfig.json
├── tsconfig.cjs.json
├── vite.config.ts
├── .npmignore
├── README.md
└── LICENSE
```

---

## 📊 Data Organization

### Data Hierarchy

```
countries.json              # Top level - all countries
  ↓
Country-CODE/
  ├── meta.json            # Country details with timezones
  └── states.json          # All states in country
      ↓
State-CODE/
  └── cities.json          # All cities in state
```

### File Format Examples (Based on Your Database Schema)

#### `src/data/countries.json`
```json
[
  {
    "id": 233,
    "name": "United States",
    "iso3": "USA",
    "iso2": "US",
    "numeric_code": "840",
    "phonecode": "1",
    "capital": "Washington",
    "currency": "USD",
    "currency_name": "United States dollar",
    "currency_symbol": "$",
    "tld": ".us",
    "native": "United States",
    "region": "Americas",
    "subregion": "Northern America",
    "nationality": "American",
    "latitude": "38.00000000",
    "longitude": "-97.00000000",
    "emoji": "🇺🇸",
    "emojiU": "U+1F1FA U+1F1F8"
  }
]
```

#### `src/data/United_States-US/meta.json`
```json
{
  "id": 233,
  "name": "United States",
  "iso3": "USA",
  "iso2": "US",
  "numeric_code": "840",
  "phonecode": "1",
  "capital": "Washington",
  "currency": "USD",
  "currency_name": "United States dollar",
  "currency_symbol": "$",
  "tld": ".us",
  "native": "United States",
  "region": "Americas",
  "subregion": "Northern America",
  "nationality": "American",
  "latitude": "38.00000000",
  "longitude": "-97.00000000",
  "emoji": "🇺🇸",
  "emojiU": "U+1F1FA U+1F1F8",
  "timezones": [
    {
      "zoneName": "America/New_York",
      "gmtOffset": -18000,
      "gmtOffsetName": "UTC-05:00",
      "abbreviation": "EST",
      "tzName": "Eastern Standard Time (North America)"
    },
    {
      "zoneName": "America/Chicago",
      "gmtOffset": -21600,
      "gmtOffsetName": "UTC-06:00",
      "abbreviation": "CST",
      "tzName": "Central Standard Time (North America)"
    }
  ],
  "translations": {
    "br": "Stadoù-Unanet",
    "ko": "미국",
    "pt-BR": "Estados Unidos",
    "de": "Vereinigte Staaten von Amerika",
    "es": "Estados Unidos",
    "fr": "États-Unis",
    "ja": "アメリカ合衆国",
    "it": "Stati Uniti D'America",
    "zh-CN": "美国",
    "ru": "Соединенные Штаты",
    "ar": "الولايات المتحدة"
  }
}
```

#### `src/data/United_States-US/states.json`
```json
[
  {
    "id": 1416,
    "name": "California",
    "country_id": 233,
    "country_code": "US",
    "fips_code": "06",
    "iso2": "CA",
    "type": "state",
    "latitude": "36.77826100",
    "longitude": "-119.41793240",
    "native": "California",
    "timezone": "America/Los_Angeles",
    "translations": {
      "ko": "캘리포니아 주",
      "pt-BR": "Califórnia",
      "de": "Kalifornien",
      "es": "California",
      "fr": "Californie",
      "ja": "カリフォルニア州",
      "ru": "Калифорния"
    }
  },
  {
    "id": 1444,
    "name": "Texas",
    "country_id": 233,
    "country_code": "US",
    "fips_code": "48",
    "iso2": "TX",
    "type": "state",
    "latitude": "31.96859880",
    "longitude": "-99.90181310",
    "native": "Texas",
    "timezone": "America/Chicago",
    "translations": {
      "ko": "텍사스 주",
      "de": "Texas",
      "es": "Texas",
      "fr": "Texas",
      "ja": "テキサス州",
      "ru": "Техас"
    }
  }
]
```

#### `src/data/United_States-US/California-CA/cities.json`
```json
[
  {
    "id": 111137,
    "name": "Los Angeles",
    "state_id": 1416,
    "state_code": "CA",
    "country_id": 233,
    "country_code": "US",
    "latitude": "34.05223400",
    "longitude": "-118.24368490",
    "native": "Los Angeles",
    "timezone": "America/Los_Angeles",
    "translations": {
      "ko": "로스앤젤레스",
      "de": "Los Angeles",
      "es": "Los Ángeles",
      "fr": "Los Angeles",
      "ja": "ロサンゼルス",
      "ru": "Лос-Анджелес"
    }
  },
  {
    "id": 111139,
    "name": "San Francisco",
    "state_id": 1416,
    "state_code": "CA",
    "country_id": 233,
    "country_code": "US",
    "latitude": "37.77492900",
    "longitude": "-122.41941550",
    "native": "San Francisco",
    "timezone": "America/Los_Angeles",
    "translations": {
      "ko": "샌프란시스코",
      "de": "San Francisco",
      "es": "San Francisco",
      "fr": "San Francisco",
      "ja": "サンフランシスコ",
      "ru": "Сан-Франциско"
    }
  }
]
```

### Naming Convention

**CRITICAL:** Use consistent naming to avoid path errors

```
Format: {Name}-{ISO2_CODE}

Examples:
- United_States-US/           # Use underscore for spaces
- California-CA/
- New_York-NY/
- United_Kingdom-GB/
```

**Why:** Dynamic imports need predictable paths. Spaces in filenames cause issues.

---

## 💻 Implementation Details

### TypeScript Interfaces (`src/types.ts`)

```typescript
/**
 * Based on your actual database schema
 */

export interface ITimezone {
  zoneName: string;
  gmtOffset: number;
  gmtOffsetName: string;
  abbreviation: string;
  tzName: string;
}

export interface ITranslations {
  [key: string]: string; // e.g., { "ko": "미국", "de": "Vereinigte Staaten", ... }
}

export interface ICountry {
  id: number;
  name: string;
  iso3: string;
  iso2: string;
  numeric_code: string;
  phonecode: string;
  capital: string;
  currency: string;
  currency_name: string;
  currency_symbol: string;
  tld: string;
  native: string;
  region: string;
  subregion: string;
  nationality: string;
  latitude: string;
  longitude: string;
  emoji: string;
  emojiU: string;
}

export interface ICountryMeta extends ICountry {
  timezones: ITimezone[];
  translations: ITranslations;
}

export interface IState {
  id: number;
  name: string;
  country_id: number;
  country_code: string;
  fips_code: string | null;
  iso2: string;
  type: string | null;
  latitude: string | null;
  longitude: string | null;
  native: string | null;
  timezone: string | null;
  translations: ITranslations;
}

export interface ICity {
  id: number;
  name: string;
  state_id: number;
  state_code: string;
  country_id: number;
  country_code: string;
  latitude: string;
  longitude: string;
  native: string | null;
  timezone: string | null;
  translations: ITranslations;
}
```

### Data Loaders (`src/loaders.ts`)

```typescript
import type { ICountry, ICountryMeta, IState, ICity } from './types';

/**
 * Get list of all countries (lightweight - no timezones/translations)
 * Bundle impact: ~15KB
 */
export async function getCountries(): Promise<ICountry[]> {
  const { default: countries } = await import('./data/countries.json');
  return countries;
}

/**
 * Get detailed metadata for a specific country (includes timezones and translations)
 * Bundle impact: ~5KB per country
 */
export async function getCountryByCode(countryCode: string): Promise<ICountryMeta | null> {
  try {
    // Use country name from countries.json to build path
    const countries = await getCountries();
    const country = countries.find(c => c.iso2 === countryCode);
    
    if (!country) {
      return null;
    }
    
    const countryDirName = `${country.name.replace(/\s+/g, '_')}-${country.iso2}`;
    const { default: meta } = await import(`./data/${countryDirName}/meta.json`);
    return meta;
  } catch (error) {
    console.error(`Country ${countryCode} not found`);
    return null;
  }
}

/**
 * Get all states for a country
 * Bundle impact: ~10-100KB depending on country
 */
export async function getStatesOfCountry(countryCode: string): Promise<IState[]> {
  try {
    const countries = await getCountries();
    const country = countries.find(c => c.iso2 === countryCode);
    
    if (!country) {
      return [];
    }
    
    const countryDirName = `${country.name.replace(/\s+/g, '_')}-${country.iso2}`;
    const { default: states } = await import(`./data/${countryDirName}/states.json`);
    return states;
  } catch (error) {
    console.error(`States for ${countryCode} not found`);
    return [];
  }
}

/**
 * Get specific state details
 * This doesn't load cities - just state info from states.json
 */
export async function getStateByCode(
  countryCode: string,
  stateCode: string
): Promise<IState | null> {
  const states = await getStatesOfCountry(countryCode);
  return states.find(s => s.iso2 === stateCode) || null;
}

/**
 * Get all cities in a state
 * Bundle impact: ~5-200KB depending on state
 */
export async function getCitiesOfState(
  countryCode: string,
  stateCode: string
): Promise<ICity[]> {
  try {
    const countries = await getCountries();
    const country = countries.find(c => c.iso2 === countryCode);
    
    if (!country) {
      return [];
    }
    
    const states = await getStatesOfCountry(countryCode);
    const state = states.find(s => s.iso2 === stateCode);
    
    if (!state) {
      return [];
    }
    
    const countryDirName = `${country.name.replace(/\s+/g, '_')}-${country.iso2}`;
    const stateDirName = `${state.name.replace(/\s+/g, '_')}-${state.iso2}`;
    
    const { default: cities } = await import(
      `./data/${countryDirName}/${stateDirName}/cities.json`
    );
    return cities;
  } catch (error) {
    console.error(`Cities for ${countryCode}/${stateCode} not found`);
    return [];
  }
}

/**
 * Get ALL cities for a country
 * Bundle impact: Large - loads all state city files
 * Only use when absolutely necessary
 */
export async function getAllCitiesOfCountry(countryCode: string): Promise<ICity[]> {
  const states = await getStatesOfCountry(countryCode);
  const allCities: ICity[] = [];
  
  for (const state of states) {
    const cities = await getCitiesOfState(countryCode, state.iso2);
    allCities.push(...cities);
  }
  
  return allCities;
}

/**
 * WARNING: This loads EVERYTHING - use sparingly!
 * Bundle impact: 8MB+
 * Only for specific use cases where user explicitly needs all data
 */
export async function getAllCitiesInWorld(): Promise<ICity[]> {
  const countries = await getCountries();
  const allCities: ICity[] = [];
  
  for (const country of countries) {
    const cities = await getAllCitiesOfCountry(country.iso2);
    allCities.push(...cities);
  }
  
  return allCities;
}

/**
 * Get a specific city by ID
 * Note: This requires loading all cities in the state first
 */
export async function getCityById(
  countryCode: string,
  stateCode: string,
  cityId: number
): Promise<ICity | null> {
  const cities = await getCitiesOfState(countryCode, stateCode);
  return cities.find(c => c.id === cityId) || null;
}
```

### Utility Functions (`src/utils.ts`)

```typescript
import type { ICountry, IState, ICity } from './types';
import { getCountries, getStatesOfCountry, getCitiesOfState } from './loaders';

/**
 * Validate if a country code exists
 */
export async function isValidCountryCode(countryCode: string): Promise<boolean> {
  const countries = await getCountries();
  return countries.some(c => c.iso2 === countryCode);
}

/**
 * Validate if a state code exists in a country
 */
export async function isValidStateCode(
  countryCode: string,
  stateCode: string
): Promise<boolean> {
  const states = await getStatesOfCountry(countryCode);
  return states.some(s => s.iso2 === stateCode);
}

/**
 * Search cities by name (partial match)
 * Note: This loads cities for the specified state only
 */
export async function searchCitiesByName(
  countryCode: string,
  stateCode: string,
  searchTerm: string
): Promise<ICity[]> {
  const cities = await getCitiesOfState(countryCode, stateCode);
  const lowerSearch = searchTerm.toLowerCase();
  return cities.filter(city => 
    city.name.toLowerCase().includes(lowerSearch)
  );
}

/**
 * Get country name by ISO2 code
 */
export async function getCountryNameByCode(countryCode: string): Promise<string | null> {
  const countries = await getCountries();
  const country = countries.find(c => c.iso2 === countryCode);
  return country?.name || null;
}

/**
 * Get state name by ISO2 code
 */
export async function getStateNameByCode(
  countryCode: string,
  stateCode: string
): Promise<string | null> {
  const states = await getStatesOfCountry(countryCode);
  const state = states.find(s => s.iso2 === stateCode);
  return state?.name || null;
}

/**
 * Get timezone for a specific location
 */
export async function getTimezoneForCity(
  countryCode: string,
  stateCode: string,
  cityName: string
): Promise<string | null> {
  const cities = await getCitiesOfState(countryCode, stateCode);
  const city = cities.find(c => c.name === cityName);
  return city?.timezone || null;
}

/**
 * Get all timezones for a country
 */
export async function getCountryTimezones(countryCode: string): Promise<string[]> {
  const countryMeta = await getCountryByCode(countryCode);
  if (!countryMeta || !countryMeta.timezones) {
    return [];
  }
  return countryMeta.timezones.map(tz => tz.zoneName);
}
```

### Main Entry Point (`src/index.ts`)

```typescript
// Export all types
export type { 
  ICountry, 
  ICountryMeta, 
  IState, 
  ICity, 
  ITimezone,
  ITranslations 
} from './types';

// Export all loaders
export {
  getCountries,
  getCountryByCode,
  getStatesOfCountry,
  getStateByCode,
  getCitiesOfState,
  getAllCitiesOfCountry,
  getAllCitiesInWorld,
  getCityById,
} from './loaders';

// Export utilities
export {
  isValidCountryCode,
  isValidStateCode,
  searchCitiesByName,
  getCountryNameByCode,
  getStateNameByCode,
  getTimezoneForCity,
  getCountryTimezones,
} from './utils';

// Default export for convenience
export { getCountries as default } from './loaders';
```

---

## 🔧 Build Configuration

### `package.json`

```json
{
  "name": "@yourdb/country-state-city",
  "version": "1.0.0",
  "description": "Official country, state, and city data with iOS/Safari support and minimal bundle size",
  "keywords": [
    "country",
    "state",
    "city",
    "location",
    "geography",
    "iso",
    "typescript",
    "ios-compatible",
    "timezone",
    "translations"
  ],
  "author": "Your Name <your.email@example.com>",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/yourusername/country-state-city.git"
  },
  "homepage": "https://github.com/yourusername/country-state-city#readme",
  "bugs": {
    "url": "https://github.com/yourusername/country-state-city/issues"
  },
  "type": "module",
  "main": "./dist/index.cjs",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "sideEffects": false,
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "require": {
        "types": "./dist/index.d.cts",
        "default": "./dist/index.cjs"
      }
    },
    "./data/*": "./dist/data/*"
  },
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "scripts": {
    "build": "npm run clean && npm run build:js && npm run build:types",
    "build:js": "vite build",
    "build:types": "tsc --declaration --emitDeclarationOnly --outDir dist",
    "clean": "rm -rf dist",
    "dev": "vite build --watch",
    "test": "vitest",
    "test:ios": "vitest --reporter=verbose compatibility",
    "lint": "eslint src --ext .ts",
    "format": "prettier --write \"src/**/*.ts\"",
    "generate-data": "ts-node scripts/generate-data.ts",
    "validate-data": "ts-node scripts/validate-data.ts",
    "prepublishOnly": "npm run validate-data && npm run build && npm test"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.0.0",
    "mysql2": "^3.0.0",
    "prettier": "^3.0.0",
    "ts-node": "^10.0.0",
    "typescript": "^5.0.0",
    "vite": "^5.0.0",
    "vite-plugin-dts": "^3.0.0",
    "vitest": "^1.0.0"
  },
  "engines": {
    "node": ">=16.0.0"
  }
}
```

### `vite.config.ts`

```typescript
import { defineConfig } from 'vite';
import { resolve } from 'path';
import dts from 'vite-plugin-dts';

export default defineConfig({
  plugins: [
    dts({
      insertTypesEntry: true,
    }),
  ],
  build: {
    lib: {
      entry: resolve(__dirname, 'src/index.ts'),
      name: 'CountryStateCity',
      formats: ['es', 'cjs'],
      fileName: (format) => `index.${format === 'es' ? 'js' : 'cjs'}`,
    },
    rollupOptions: {
      // Don't bundle JSON files - keep them external for dynamic loading
      external: [
        /^\.\/data\/.*/,
      ],
      output: {
        // Preserve directory structure
        preserveModules: false,
        // Ensure data files are copied
        assetFileNames: (assetInfo) => {
          if (assetInfo.name?.endsWith('.json')) {
            // Keep JSON in data/ folder structure
            return 'data/[name][extname]';
          }
          return 'assets/[name][extname]';
        },
      },
    },
    // Copy data directory to dist
    copyPublicDir: false,
  },
  // Ensure data files are included
  assetsInclude: ['**/*.json'],
});
```

**CRITICAL:** This config does NOT combine JSON files. It preserves the split structure.

### `tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020"],
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "types": ["node", "vite/client"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

### `tsconfig.cjs.json`

```json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",
    "outDir": "./dist/cjs"
  }
}
```

### `.npmignore`

```
# Source files
src/
scripts/
tests/

# Config files
*.config.ts
*.config.js
tsconfig*.json
.eslintrc*
.prettierrc*

# Development
node_modules/
.git/
.github/
*.log
*.lock
coverage/

# Keep only dist in published package
!dist/
```

---

## 🎨 API Design

### Basic Usage Examples

```typescript
import {
  getCountries,
  getStatesOfCountry,
  getCitiesOfState,
  getCountryByCode,
} from '@yourdb/country-state-city';

// Get all countries (~15KB)
const countries = await getCountries();
console.log(countries.length); // 250+ countries
console.log(countries[0].emoji); // 🇺🇸

// Get country details with timezone info
const usa = await getCountryByCode('US');
console.log(usa?.timezones); // Array of US timezones
console.log(usa?.currency_symbol); // $

// Get states of a country
const usStates = await getStatesOfCountry('US');
console.log(usStates.length); // 50+ states

// Get cities of a state
const caCities = await getCitiesOfState('US', 'CA');
console.log(caCities.length);
console.log(caCities[0].timezone); // America/Los_Angeles
```

### Advanced Usage

```typescript
import {
  getAllCitiesOfCountry,
  searchCitiesByName,
  isValidCountryCode,
  getCountryTimezones,
  type ICity,
} from '@yourdb/country-state-city';

// Validate codes
const isValid = await isValidCountryCode('US'); // true

// Search cities (within a state)
const results = await searchCitiesByName('US', 'NY', 'new');
// Returns cities like: New York, New Rochelle, etc.

// Get all US timezones
const timezones = await getCountryTimezones('US');
console.log(timezones); 
// ['America/New_York', 'America/Chicago', 'America/Los_Angeles', ...]

// Get all cities in a country (caution: large!)
const allUSCities = await getAllCitiesOfCountry('US');
```

### React Example with Translations

```typescript
import { useState, useEffect } from 'react';
import { 
  getCountries, 
  getStatesOfCountry, 
  getCitiesOfState 
} from '@yourdb/country-state-city';
import type { ICountry, IState, ICity } from '@yourdb/country-state-city';

function LocationSelector() {
  const [countries, setCountries] = useState<ICountry[]>([]);
  const [states, setStates] = useState<IState[]>([]);
  const [cities, setCities] = useState<ICity[]>([]);
  
  const [selectedCountry, setSelectedCountry] = useState('');
  const [selectedState, setSelectedState] = useState('');
  const [language, setLanguage] = useState('en');

  // Load countries on mount
  useEffect(() => {
    getCountries().then(setCountries);
  }, []);

  // Load states when country changes
  useEffect(() => {
    if (selectedCountry) {
      getStatesOfCountry(selectedCountry).then(setStates);
      setSelectedState('');
      setCities([]);
    }
  }, [selectedCountry]);

  // Load cities when state changes
  useEffect(() => {
    if (selectedCountry && selectedState) {
      getCitiesOfState(selectedCountry, selectedState).then(setCities);
    }
  }, [selectedCountry, selectedState]);

  // Get translated name
  const getTranslatedName = (
    item: ICountry | IState | ICity, 
    lang: string
  ): string => {
    if ('translations' in item && item.translations && item.translations[lang]) {
      return item.translations[lang];
    }
    return item.name;
  };

  return (
    <div>
      <select onChange={(e) => setLanguage(e.target.value)}>
        <option value="en">English</option>
        <option value="es">Español</option>
        <option value="fr">Français</option>
        <option value="de">Deutsch</option>
        <option value="ja">日本語</option>
      </select>

      <select onChange={(e) => setSelectedCountry(e.target.value)}>
        <option value="">Select Country</option>
        {countries.map(c => (
          <option key={c.iso2} value={c.iso2}>
            {c.emoji} {getTranslatedName(c, language)}
          </option>
        ))}
      </select>

      <select 
        onChange={(e) => setSelectedState(e.target.value)}
        disabled={!selectedCountry}
      >
        <option value="">Select State</option>
        {states.map(s => (
          <option key={s.iso2} value={s.iso2}>
            {getTranslatedName(s, language)}
          </option>
        ))}
      </select>

      <select disabled={!selectedState}>
        <option value="">Select City</option>
        {cities.map((c) => (
          <option key={c.id} value={c.id}>
            {getTranslatedName(c, language)} 
            {c.timezone && ` (${c.timezone})`}
          </option>
        ))}
      </select>
    </div>
  );
}
```

---

## 🗄️ Database Integration

### Connection Setup

Create a `.env` file (NOT committed to git):
```env
DB_HOST=localhost
DB_PORT=3306
DB_USER=your_username
DB_PASSWORD=your_password
DB_NAME=world
```

### Data Generation Script (`scripts/generate-data.ts`)

```typescript
import mysql from 'mysql2/promise';
import fs from 'fs/promises';
import path from 'path';
import dotenv from 'dotenv';

dotenv.config();

// Database connection
const pool = mysql.createPool({
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '3306'),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME || 'world',
  waitForConnections: true,
  connectionLimit: 10,
});

interface DBCountry {
  id: number;
  name: string;
  iso3: string;
  numeric_code: string;
  iso2: string;
  phonecode: string;
  capital: string;
  currency: string;
  currency_name: string;
  currency_symbol: string;
  tld: string;
  native: string;
  population: number;
  gdp: number;
  region: string;
  region_id: number;
  subregion: string;
  subregion_id: number;
  nationality: string;
  timezones: string; // JSON string
  translations: string; // JSON string
  latitude: string;
  longitude: string;
  emoji: string;
  emojiU: string;
}

interface DBState {
  id: number;
  name: string;
  country_id: number;
  country_code: string;
  fips_code: string | null;
  iso2: string;
  iso3166_2: string | null;
  type: string | null;
  level: number | null;
  parent_id: number | null;
  native: string | null;
  latitude: string | null;
  longitude: string | null;
  timezone: string | null;
  translations: string; // JSON string
}

interface DBCity {
  id: number;
  name: string;
  state_id: number;
  state_code: string;
  country_id: number;
  country_code: string;
  latitude: string;
  longitude: string;
  native: string | null;
  timezone: string | null;
  translations: string; // JSON string
}

async function fetchAllCountries(): Promise<DBCountry[]> {
  const [rows] = await pool.query<any[]>(
    `SELECT 
      id, name, iso3, numeric_code, iso2, phonecode, capital, 
      currency, currency_name, currency_symbol, tld, native,
      region, subregion, nationality, timezones, translations,
      latitude, longitude, emoji, emojiU
    FROM countries 
    WHERE flag = 1
    ORDER BY name ASC`
  );
  return rows;
}

async function fetchStatesByCountry(countryId: number): Promise<DBState[]> {
  const [rows] = await pool.query<any[]>(
    `SELECT 
      id, name, country_id, country_code, fips_code, iso2,
      type, latitude, longitude, native, timezone, translations
    FROM states 
    WHERE country_id = ? AND flag = 1
    ORDER BY name ASC`,
    [countryId]
  );
  return rows;
}

async function fetchCitiesByState(stateId: number): Promise<DBCity[]> {
  const [rows] = await pool.query<any[]>(
    `SELECT 
      id, name, state_id, state_code, country_id, country_code,
      latitude, longitude, native, timezone, translations
    FROM cities 
    WHERE state_id = ? AND flag = 1
    ORDER BY name ASC`,
    [stateId]
  );
  return rows;
}

async function generateDataFiles() {
  const dataDir = path.resolve(__dirname, '../src/data');
  
  // Ensure data directory exists
  await fs.mkdir(dataDir, { recursive: true });

  console.log('Fetching countries from database...');
  const dbCountries = await fetchAllCountries();
  console.log(`Found ${dbCountries.length} countries`);

  // Prepare lightweight countries list (no timezones/translations)
  const countriesList = dbCountries.map(c => ({
    id: c.id,
    name: c.name,
    iso3: c.iso3,
    iso2: c.iso2,
    numeric_code: c.numeric_code,
    phonecode: c.phonecode,
    capital: c.capital,
    currency: c.currency,
    currency_name: c.currency_name,
    currency_symbol: c.currency_symbol,
    tld: c.tld,
    native: c.native,
    region: c.region,
    subregion: c.subregion,
    nationality: c.nationality,
    latitude: c.latitude,
    longitude: c.longitude,
    emoji: c.emoji,
    emojiU: c.emojiU,
  }));

  // Write countries.json
  await fs.writeFile(
    path.join(dataDir, 'countries.json'),
    JSON.stringify(countriesList, null, 2)
  );
  console.log(`✓ Written countries.json`);

  // Process each country
  for (const country of dbCountries) {
    const countryDirName = `${country.name.replace(/\s+/g, '_')}-${country.iso2}`;
    const countryDir = path.join(dataDir, countryDirName);
    
    await fs.mkdir(countryDir, { recursive: true });

    console.log(`\nProcessing ${country.name}...`);

    // Parse JSON fields
    const timezones = country.timezones ? JSON.parse(country.timezones) : [];
    const translations = country.translations ? JSON.parse(country.translations) : {};

    // Write country meta.json (with timezones and translations)
    const countryMeta = {
      ...countriesList.find(c => c.id === country.id),
      timezones,
      translations,
    };
    await fs.writeFile(
      path.join(countryDir, 'meta.json'),
      JSON.stringify(countryMeta, null, 2)
    );

    // Fetch and write states
    const dbStates = await fetchStatesByCountry(country.id);
    
    const statesList = dbStates.map(s => ({
      id: s.id,
      name: s.name,
      country_id: s.country_id,
      country_code: s.country_code,
      fips_code: s.fips_code,
      iso2: s.iso2,
      type: s.type,
      latitude: s.latitude,
      longitude: s.longitude,
      native: s.native,
      timezone: s.timezone,
      translations: s.translations ? JSON.parse(s.translations) : {},
    }));

    await fs.writeFile(
      path.join(countryDir, 'states.json'),
      JSON.stringify(statesList, null, 2)
    );

    console.log(`  ✓ ${dbStates.length} states`);

    // Process each state
    for (const state of dbStates) {
      const stateDirName = `${state.name.replace(/\s+/g, '_')}-${state.iso2}`;
      const stateDir = path.join(countryDir, stateDirName);
      
      await fs.mkdir(stateDir, { recursive: true });

      // Fetch and write cities
      const dbCities = await fetchCitiesByState(state.id);
      
      const citiesList = dbCities.map(c => ({
        id: c.id,
        name: c.name,
        state_id: c.state_id,
        state_code: c.state_code,
        country_id: c.country_id,
        country_code: c.country_code,
        latitude: c.latitude,
        longitude: c.longitude,
        native: c.native,
        timezone: c.timezone,
        translations: c.translations ? JSON.parse(c.translations) : {},
      }));

      await fs.writeFile(
        path.join(stateDir, 'cities.json'),
        JSON.stringify(citiesList, null, 2)
      );

      console.log(`    ✓ ${state.name}: ${dbCities.length} cities`);
    }
  }

  await pool.end();
  console.log('\n✨ Data generation complete!');
}

generateDataFiles().catch((error) => {
  console.error('Error generating data:', error);
  process.exit(1);
});
```

### Validation Script (`scripts/validate-data.ts`)

```typescript
import fs from 'fs/promises';
import path from 'path';

async function validateDataStructure() {
  const dataDir = path.resolve(__dirname, '../src/data');
  let errors = 0;

  console.log('Validating data structure...\n');

  // Check countries.json exists
  try {
    const countriesPath = path.join(dataDir, 'countries.json');
    const countriesData = await fs.readFile(countriesPath, 'utf-8');
    const countries = JSON.parse(countriesData);

    if (!Array.isArray(countries)) {
      console.error('❌ countries.json is not an array');
      errors++;
    } else {
      console.log(`✓ countries.json (${countries.length} countries)`);

      // Validate each country has required fields
      for (const country of countries) {
        if (!country.iso2 || !country.name) {
          console.error(`❌ Country missing required fields: ${JSON.stringify(country)}`);
          errors++;
          continue;
        }

        // Check country directory exists
        const countryDirName = `${country.name.replace(/\s+/g, '_')}-${country.iso2}`;
        const countryDir = path.join(dataDir, countryDirName);

        try {
          await fs.access(countryDir);
          
          // Check meta.json
          const metaPath = path.join(countryDir, 'meta.json');
          const metaData = await fs.readFile(metaPath, 'utf-8');
          const meta = JSON.parse(metaData);
          
          if (!meta.timezones || !Array.isArray(meta.timezones)) {
            console.error(`❌ ${country.name}: meta.json missing timezones array`);
            errors++;
          }

          // Check states.json
          const statesPath = path.join(countryDir, 'states.json');
          const statesData = await fs.readFile(statesPath, 'utf-8');
          const states = JSON.parse(statesData);

          if (!Array.isArray(states)) {
            console.error(`❌ ${country.name}: states.json is not an array`);
            errors++;
            continue;
          }

          console.log(`  ✓ ${country.name}: ${states.length} states`);

          // Validate each state directory
          for (const state of states) {
            if (!state.iso2 || !state.name) {
              console.error(`❌ State missing required fields: ${JSON.stringify(state)}`);
              errors++;
              continue;
            }

            const stateDirName = `${state.name.replace(/\s+/g, '_')}-${state.iso2}`;
            const stateDir = path.join(countryDir, stateDirName);

            try {
              await fs.access(stateDir);
              
              const citiesPath = path.join(stateDir, 'cities.json');
              const citiesData = await fs.readFile(citiesPath, 'utf-8');
              const cities = JSON.parse(citiesData);

              if (!Array.isArray(cities)) {
                console.error(`❌ ${country.name}/${state.name}: cities.json is not an array`);
                errors++;
              }
            } catch (e) {
              console.error(`❌ Missing state directory or cities.json: ${countryDirName}/${stateDirName}`);
              errors++;
            }
          }
        } catch (e) {
          console.error(`❌ Missing country directory or files: ${countryDirName}`);
          errors++;
        }
      }
    }
  } catch (e) {
    console.error('❌ countries.json not found or invalid JSON');
    errors++;
  }

  console.log(`\n${errors === 0 ? '✨' : '⚠️'} Validation complete`);
  if (errors > 0) {
    console.error(`Found ${errors} error(s)`);
    process.exit(1);
  }
}

validateDataStructure().catch(console.error);
```

---

## 🧪 Testing Requirements

### Unit Tests (`tests/unit/loaders.test.ts`)

```typescript
import { describe, it, expect } from 'vitest';
import {
  getCountries,
  getStatesOfCountry,
  getCitiesOfState,
  getCountryByCode,
} from '../../src/loaders';

describe('Data Loaders', () => {
  describe('getCountries', () => {
    it('should return array of countries', async () => {
      const countries = await getCountries();
      expect(Array.isArray(countries)).toBe(true);
      expect(countries.length).toBeGreaterThan(0);
    });

    it('should have required country properties', async () => {
      const countries = await getCountries();
      const country = countries[0];
      
      expect(country).toHaveProperty('iso2');
      expect(country).toHaveProperty('name');
      expect(country).toHaveProperty('phonecode');
      expect(country).toHaveProperty('emoji');
      expect(country).toHaveProperty('currency');
    });
  });

  describe('getCountryByCode', () => {
    it('should return country metadata with timezones', async () => {
      const usa = await getCountryByCode('US');
      
      expect(usa).not.toBeNull();
      expect(usa?.iso2).toBe('US');
      expect(usa?.name).toBe('United States');
      expect(usa?.timezones).toBeDefined();
      expect(Array.isArray(usa?.timezones)).toBe(true);
      expect(usa?.translations).toBeDefined();
    });

    it('should return null for invalid code', async () => {
      const invalid = await getCountryByCode('INVALID');
      expect(invalid).toBeNull();
    });
  });

  describe('getStatesOfCountry', () => {
    it('should return states for US', async () => {
      const states = await getStatesOfCountry('US');
      
      expect(Array.isArray(states)).toBe(true);
      expect(states.length).toBeGreaterThan(0);
      expect(states[0]).toHaveProperty('iso2');
      expect(states[0]).toHaveProperty('name');
      expect(states[0].country_code).toBe('US');
    });

    it('should return empty array for invalid country', async () => {
      const states = await getStatesOfCountry('INVALID');
      expect(states).toEqual([]);
    });
  });

  describe('getCitiesOfState', () => {
    it('should return cities for California', async () => {
      const cities = await getCitiesOfState('US', 'CA');
      
      expect(Array.isArray(cities)).toBe(true);
      expect(cities.length).toBeGreaterThan(0);
      expect(cities[0]).toHaveProperty('name');
      expect(cities[0].country_code).toBe('US');
      expect(cities[0].state_code).toBe('CA');
      expect(cities[0]).toHaveProperty('timezone');
    });

    it('should return empty array for invalid state', async () => {
      const cities = await getCitiesOfState('US', 'INVALID');
      expect(cities).toEqual([]);
    });
  });
});
```

### iOS Compatibility Tests (`tests/compatibility/ios-safari.test.ts`)

```typescript
import { describe, it, expect } from 'vitest';
import {
  getCountries,
  getStatesOfCountry,
  getCitiesOfState,
  getAllCitiesOfCountry,
} from '../../src/loaders';

describe('iOS Safari Compatibility', () => {
  it('should load countries without stack overflow', async () => {
    const countries = await getCountries();
    expect(countries).toBeDefined();
    expect(countries.length).toBeGreaterThan(0);
  });

  it('should load states without stack overflow', async () => {
    const states = await getStatesOfCountry('US');
    expect(states).toBeDefined();
    expect(states.length).toBeGreaterThan(0);
  });

  it('should load cities without stack overflow', async () => {
    const cities = await getCitiesOfState('US', 'CA');
    expect(cities).toBeDefined();
    expect(cities.length).toBeGreaterThan(0);
  });

  it('should handle multiple sequential loads', async () => {
    // Simulates user selecting country → state → city
    const countries = await getCountries();
    expect(countries.length).toBeGreaterThan(0);

    const states = await getStatesOfCountry('US');
    expect(states.length).toBeGreaterThan(0);

    const cities = await getCitiesOfState('US', 'CA');
    expect(cities.length).toBeGreaterThan(0);
  });

  it('should not exceed reasonable bundle size', async () => {
    const countries = await getCountries();
    const size = JSON.stringify(countries).length;
    
    // Countries list should be under 50KB
    expect(size).toBeLessThan(50 * 1024);
  });

  it('should handle loading large country data', async () => {
    // US has many states - good stress test
    const cities = await getAllCitiesOfCountry('US');
    expect(cities.length).toBeGreaterThan(100);
  });
});
```

---

## 📦 Publishing Checklist

### Pre-Publish Validation

1. **Setup Database Connection**
   ```bash
   # Copy .env.example to .env and fill in your database credentials
   cp .env.example .env
   ```

2. **Generate Data from Database**
   ```bash
   npm run generate-data
   ```

3. **Run Data Validation**
   ```bash
   npm run validate-data
   ```

4. **Run All Tests**
   ```bash
   npm test
   ```

5. **Test iOS Compatibility Specifically**
   ```bash
   npm run test:ios
   ```

6. **Check Bundle Size**
   ```bash
   npm run build
   ls -lh dist/index.js  # Should be under 50KB
   ls -lh dist/data/countries.json  # Should be under 50KB
   ```

7. **Test Local Installation**
   ```bash
   npm pack
   # Creates a .tgz file
   
   # In a test project:
   npm install /path/to/yourdb-country-state-city-1.0.0.tgz
   ```

8. **Test on BrowserStack iOS**
   - Safari on iPhone 12+
   - Safari on iPad
   - Chrome on iOS

### Publishing Steps

```bash
# 1. Login to npm
npm login

# 2. Dry run to see what will be published
npm publish --dry-run

# 3. Publish
npm publish --access public

# 4. Create git tag
git tag v1.0.0
git push origin v1.0.0

# 5. Create GitHub release with changelog
```

### Post-Publish Verification

1. **Check on npm**
   - Visit: https://www.npmjs.com/package/@yourdb/country-state-city
   - Verify files are correct

2. **Check on Bundlephobia**
   - Visit: https://bundlephobia.com/package/@yourdb/country-state-city
   - Verify bundle size metrics

3. **Test Installation**
   ```bash
   npx create-vite test-app --template react-ts
   cd test-app
   npm install @yourdb/country-state-city
   # Test the package works
   ```

---

## 📚 Additional Documentation

### Environment Variables

Create `.env.example`:
```env
DB_HOST=localhost
DB_PORT=3306
DB_USER=your_username
DB_PASSWORD=your_password
DB_NAME=world
```

### Database Schema Notes

Your database uses:
- `iso2` for 2-letter country/state codes
- `translations` as JSON text field
- `timezones` as JSON array in countries
- Foreign keys: `state.country_id` → `countries.id`, `city.state_id` → `states.id`

---

## 🎯 Success Metrics

After publishing, track:

1. **Bundle Size**
   - Initial: <10KB ✅
   - With country list: <50KB ✅
   - With state data: <100KB ✅

2. **iOS Compatibility**
   - No stack overflow errors ✅
   - Works on Safari iOS 13+ ✅

3. **Performance**
   - Country list loads: <100ms ✅
   - State data loads: <200ms ✅
   - City data loads: <500ms ✅

4. **Developer Experience**
   - TypeScript autocomplete works ✅
   - Translations support ✅
   - Timezone data available ✅

---

**END OF SPECIFICATION**

This specification is now tailored to your exact database schema. Pass this to Claude Code to build the package correctly!
